---
{"dg-publish":true,"dg-path":"2. 计算机综合/组成原理和操作系统/磁盘和文件/6. 文件相关.md","permalink":"/2///6/"}
---

### 底层文件系统的组织
操作系统的一个重要功能就是管理文件，操作系统面对的是一个一个的磁盘块，因此操作必须要把这些磁盘块给管理起来，他得知道哪个文件从哪个磁盘块开始，又到哪个磁盘块结束。
unix 类的操作系统使用 `inode` 节点来实现这个目的，在 `ext` 类的文件系统中，磁盘被划分为固定大小的几个组，每个组的开始的位置是固定使用的，不能被用于存储用户的文件，而是存储这个组的元信息，整个组被划分为如下区域：
* Superblock
* Group Descriptor table
* Block Bitmap
* Inode bitmap
* Inode Table（存储本组中的 Inode 们）
* Data Blocks
在 Inode 表中存储的是一个一个的 inode，inode 包含的信息如下：
![6. 文件相关_2025-12-09_16-09-05.png|400](/img/user/attachments/6.%20%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3_2025-12-09_16-09-05.png)
> 注意，不包含文件名和文件的实际内容。
> 文件的实际内容在数据块指针指向的位置。
> 而文件名则存储在文件类型=目录的这种特殊文件的数据块中（对应的文件的 inode 也在目录文件的数据块中，文件名和 Inode 的 mapping 关系统一称之为目录项）。
> 即 Unix 的万物皆文件的思想，这些目录类的文件中存储的内容就是他之下的文件名和该文件对应的 Inode 编号

有了 Inode 这一套数据结构之后，OS 已经可以在众多的磁盘块之中准确的管理文件了。

### 文件
对于 unix 类的操作系统，文件是通过 `inode` 方式来管理的，`inode` 是文件的索引结构，记录了文件的元数据，比如文件类型（目录还是文件）、权限、所有者、大小、时间戳、引用数（硬连接引用数）、数据块指针信息，但是不包含目录和文件的内容。
文件的内容存储在数据块中，通过 `inode` 中的数据块指针指向文件内容。
操作系统有一个 `inode表` ，里面唯一存储了所有的 `inode` ，每一行一个。
操作系统还有一个 `系统文件打开表` ,记录了所有进程当前打开的文件，每一行表示一个打开的文件，里面有 `inode` 编号，表示打开的是哪一个文件。
每一个进程还有一个 `文件描述符` 表，记录了本进程打开的文件，每一行表示本进程可以访问的文件，里面有 `进程文件打开表` 的编号。
### 目录
Linux 系统中的目录都存储在 `目录文件` 这个特殊文件中（位于硬盘），每个目录项中记录了里面的文件名字以及对应的 inode 编号、和子目录信息。
用户在终端里看到的文件名，实际上是文件链接，分为硬链接和软链接两种。
* 硬链接
1. 创建一个文件名，指向一个 `inode`，用户通过该文件名访问文件的时候，会显示对应的 `inode` 指向的文件内容。
2. 可以通过 `ln A D` 命令来创建一个文件名 D，文件名 D 指向的是和 A 相同的一个 `inode`，因此创建硬链接的时候，不会在系统的 `inode` 表中增加行数.
3. 因此如果通过 `vim D` 修改了文件「D」，实际上是修改了对应 `inode` 里的内容，此时再通过 `echo A` 会发现 A 的内容已经变成了修改后的。
4. 操作系统在 `inode表` 中记录了每一个 `inode` 的硬链接引用数，当删除文件名 `A` 的时候，对应的 `inode` 硬链接引用数会减 1
5. 当一个 `inode` 的硬链接引用数减成 0 的时候，操作系统会删除该 ` inode `
* 软连接
1. 也叫符号链接，里面存储的是文件的目录地址，用户通过该文件名访问文件的时候，会先查到里面的目录地址，然后再次将目录地址位置的文件对应的 inode 的内容显示出来
2. 可以通过 `ln -s A C` 命令创建 A 的符号链接 C
3. 创建符号链接是一个新的文件（有独立的内容，内容记录的是路径），因此会在系统的 `inode表` 中增加行数.
### 文件的打开和进程间的共享
接下来就是操作文件，操作文件需要解决两个问题，一个是 OS 得对这些文件做一个统一的管理，以便应对多个进程同时访问同一个文件的场景，另外一个问题就是一个进程可能会同时打开多个文件，需要给进程一个更容易的视角。

OS 的系统级别使用的是「系统文件打开表（system wide Open file Table）」，当进程通过系统调用 `open` 打开文件的时候，OS 会在这个表中==增加一条数据==（不同进程打开同一个文件的时候，会在表里插入多条数据，因此，不同进程打开同一个文件时，对该文件的的偏移量是独立管理的.除非是子进程 fork() 父进程，或者是显性的通过 dup() 创建复用）。
系统文件打开表中的每行包含以下信息

| 字段名      | 字段说明                                       |
| -------- | ------------------------------------------ |
| 编号       | 系统文件打开表的主键，自增编号，用于索引                       |
| inode 地址 | 被打开文件的 inode 指针（即地址）                       |
| 打开模式     | rw（读写）/ r（只读）                              |
| 当前偏移量    | 120 当前的偏移量，当多个进程（例如父子）同时访问一个文件的时候，可以共享这个信息 |
| 状态标志     | 文件是否阻塞                                     |
| 引用计数     | 一个数字，例如2，代表被多少个进程引用了                       |
| 指向的文件路径  | /home/users/a.txt                          |
即 inode 是全局复用的，不会重复创建，每个系统进程打开的时候会有独立的系统文件打开表表项，用于单独管理该进程的打开模式、偏移量。

在进程粒度，每个进程会有自己的进程描述符表 `File Descriptor Table` ,存储在 OS 的内核中，每个进程独立。这个表的作用是给进程一个独立的视角，使用连续的文件描述符（整数），而不是 OS 提供的 Inode 来访问/操作文件。
表的内容如下：

| 字段         | 解释                |
| ---------- | ----------------- |
| 文件描述符（fd）  | 一个整形变量，不同值代表不同文件。 |
| 指向系统文件表项编号 | 对应的系统文件打开表的主键     |

### 进程打开文件的完整流程
#### 一个进程要打开一个文件
1. 该进程通过 `open` 系统调用打开文件
2. OS 进入内核态，系统调用会检查必要的权限、文件是否存在等校验。
3. 如果检查通过，该文件之前没被打开过，则 OS 将对应的 Inode 调入内存，并在系统文件打开表中增加一条记录，指向该 Inode，如果已经打开过，则 Inode 肯定在内存，只需要在系统文件打开表中新增一条记录即可。
4. 在该进程的文件描述符表中增加一条记录，并指向系统文件打开表中的那个记录。
5. 系统调用返回文件描述符
6. 该进程可以使用文件描述符进行操作。