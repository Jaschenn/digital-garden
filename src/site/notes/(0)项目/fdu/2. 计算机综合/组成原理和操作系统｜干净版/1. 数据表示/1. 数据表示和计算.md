---
{"dg-publish":true,"dg-path":"2. 计算机综合/组成原理和操作系统｜干净版/1. 数据表示/1. 数据表示和计算.md","permalink":"/2//1/1/"}
---


### 十六进制和二进制转换
每一个十六进制数字表示 4 个二进制数字.

| 十六进制 | 二进制  | 十进制 |
| ---- | ---- | --- |
| 0    | 0000 | 0   |
| 1    | 0001 | 1   |
| 2    | 0010 | 2   |
| 3    | 0011 | 3   |
| 4    | 0100 | 4   |
| 5    | 0101 | 5   |
| 6    | 0110 | 6   |
| 7    | 0111 | 7   |
| 8    | 1000 | 8   |
| 9    | 1001 | 9   |
| A    | 1010 | 10  |
| B    | 1011 | 11  |
| C    | 1100 | 12  |
| D    | 1101 | 13  |
| E    | 1110 | 14  |
| F    | 1111 | 15  |

### 整数表示
#### BCD 编码
用一个四位的二进制来表示一个 10 进制的数字，比如 0000 表示 0，0100 表示 4，0101 表示 5
#### 无符号数直接表示
只能够表示>=0 的数字，8 位二进制表示能够表示的范围是 $[0,2^{8}-1]$
#### 有符号数表示
##### 原码
原码逻辑很简单，就是用最高位来表示正负，其余位置表示数值大小，因此一个 8 位的二进制数可以表示的范围是 $[-2^{8-1},2^{8-1}]$

最高位是 1 表示是负数，最高位是 0 表示正数。
##### 补码
补码表示法也是用最高位表示正负，最高位如果是 1 的话，那么该数就是负数。但表示负数的时候，其余位要采用取反+1 的原则。（这是为了让加法和减法都能够使用加法表示）

> 例如：
	5 表示为 8 位二进制：正数和无符号数表示一样。
		`0000 0101`
	-5 表示为 8 位二进制：负数采用「取反+1」 的原则：
		先写出 5 的补码： `0000 0101` （整数都是 8 位）
		然后每一位取反：  `1111 1010`
		最后一位+1:      `1111 1011`

>  另外，求一个数的补码还可以逆用补码的性质：n 位负数的补码 = 2^n - 对应的正数的补码（即原码）
>  还是用 -5 的 8 位补码举例子，5 是 `0000 0101` ,2^8 是 `1 0000 0000` 
>  所以-5 的补码就是 `1 0000 0000` - `0000 0101` = `1111 1011`
		


补码的优势在于加减法可以都用加法来表示，5-5直接让他们的二进制表示相加即可 : 5+(-5)
0000 0101 + 1111 1011 = 0000 0000 因为只有 8 位，最高位的 1 会直接省略掉，答案就是正确的 0.

8 位补码能表示的数字范围：$[-2^8-1,2^{8-1}]$ 

从补码表示的二进制恢复到 10 进制的过程如下：
1111 1011 最高位是 1，表示这是一个负数，因此需要取反加 1 流程，对其取反是 0000 0100，然后加 1 就是 0000 0101，然后恢复十进制就是 5.

补码除了使用取反加一之外，还有一个重要性质是 n 位的 x 和 x 的补码加在一起是 $\displaystyle 2^n$ (正好进 1 位)

### 浮点数表示
1+8+23 规则：
[0]==000 0000 0==_000 0000 0000 0000 0000 0000_

IEEE 754 标准下的浮点数规则：
$$
浮点数=(-1)^{符号位} ✖️ 1.尾数 ✖️ 2^{指数-127}
$$
总共 32 位，占 4 个字节 (Byte)
	符号位：1 位 位正负标志位
	指数：8 位阶码，用无符号正数表示，__存储带偏置的指数__，阶码全 0 或者全 1 有特殊含义。
	尾数：23 位尾数，存储小数部分（隐藏前导 1，不存储）
	
> 8 位无符号整数可以表示的范围是[0, 255] 通过偏置+127 后，实际表示的指数范围是[-127,128]，但其中的-127 和 128 有特殊含义，是保留字。
> 
> 其中-127（阶码全为 0）表示其是一个很小的数，如果尾数是 0，则表示的是 0.
> 如果尾数不是 0，则表示的是 $\displaystyle 2^{-126} \cdot 0.尾数$ （没有隐含的 1，且指数部分是固定的-126）
> 
> 128（阶码全为 1）时表示是一个很大的数，如果此时尾数都是 0，表示的是正负无穷
> 尾数如果不是 0 的话，表示的则是非数。


> 例如，($-8.75 \cdot2^5$) 按照 IEEE 标准写成：
1. 先把 8.75 写成二进制形式：`1000.11`
2. 然后变成标准的 $1.$ 几的标准形式：$1.00011\cdot 2^8$
3. 最终结果：
	1. 标志位：1, 代表是一个负数.
	2. 阶码（指数）：8+127 的二进制形式= `8+128-1` = `0000 1000 + 1000 0000 - 0000 0001 = 1000 1000 - 0000 0001 = 1000 0111`
	3. 尾数（不够 23 位用 0 补充）：`00011 0000 0000 0000 0000 0000 000`
	4. 完整的就是：`1100 0011 1000 1100 0000 0000 0000 0000`
### 类型转换

| 类型     | 32 位系统位数 | 64 位系统 |
| ------ | -------- | ------ |
| char   | 8 位      | 8 位    |
| short  | 16 位     | 16 位   |
| int    | 32 位     | 32 位   |
| long   | 32 位     | 64 位   |
| float  | 32 位     | 32 位   |
| double | 64 位     | 64 位   |
「整形提升」当数据从 short 转为 int 类型时，由于长度需要从 16 位填充为 32 位，多出来的高位根据 short 的高位位 1 还是 0 全部填充为 1 或 0，填充后，不改变数据的大小.
	如果是 1，表示是一个负数，那么数据是以补码存储的（取反+1）都填充为 1 即可.
	如果是 0，表示是一个正数，那么数据是以原码方式存储的，都填充为 0 即可.
