---
{"dg-publish":true,"dg-path":"2. 计算机综合/组成原理和操作系统/4. 总线和 IO/4. IO 相关.md","permalink":"/2//4-io/4-io/"}
---

## IO接口
### 硬件层次结构
![4. IO 相关_2025-12-11_18-38-55.png](/img/user/attachments/4.%20IO%20%E7%9B%B8%E5%85%B3_2025-12-11_18-38-55.png)

### 软件层次结构

软件层次可以分为这几层

| 层次        | 解释                                             |
| --------- | ---------------------------------------------- |
| 用户层 IO 软件 | OS 提供，像用户提供标准接口，例如 `std::in` 或者是 `printf()` 函数 |
| 设备独立性软件   | OS 提供，用于抽象不同硬件的差异                              |
| 设备驱动和程序   | 一般是硬件制造商提供，运行于 CPU 的内核态.                       |
| 中断处理程序    | 专门处理中断的程序，在最底层.                                |
| 硬件        | 实际做操作的硬件.                                      |
### 硬件细节
IO 接口规格、
硬件中的有缓存，数据可以在硬件中缓存然后成批交付，例如网卡可以按字节交付数据.
以及硬件的编制方式，可以统一编制，可以独立编制.

## IO方式
### 程序查询方式
CPU 定时来看有没有好，如果好了就直接和 IO设备之间传输数据，如果没有好的话，就过一会再来问.
### 程序中断方式获取 IO 设备状态
CPU 获取 IO 设备状态的方式有两种，一种是程序查询方式，就是 CPU 不断的来问 IO 设备准备好没好，显然这种方式是比较慢的，另外一种方式就是在 IO 准备数据期间，CPU 正常处理其他指令，当 IO 数据准备好了之后，就发一个中断信号给 CPU，这时 CPU 会暂停当前正在执行的任务，处理中断，然后恢复执行被中断的任务。这种方式效率比较高。
为了实现这个过程，需要有：
* 系统中断向量（指向中断处理程序入口的指针）
* 中断向量表（将中断号映射到中断处理程序的地址）
* 中断服务程序（ISR）（一段特殊代码，用于响应特定的中断事件，保存被中断程序的上下文例如寄存器状态，处理中断事件例如读取硬件设备的数据，恢复中断程序的上下文例如恢复寄存器状态。）
* ![6. 总线和输入输出设备_2025-07-19_17-44-22.png](/img/user/attachments/6.%20%E6%80%BB%E7%BA%BF%E5%92%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87_2025-07-19_17-44-22.png)

详见 [[(0)项目/fdu/2. 计算机综合/组成原理和操作系统/3. CPU 和指令系统/3. 中断机制\|3. 中断机制]]
#### IO 请求到应答的流程

![5. IO 管理_2025-08-01_17-41-28.png|400](/img/user/(0)%E9%A1%B9%E7%9B%AE/fdu/2.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f-%E5%9B%BE%E8%A1%A8%E6%96%87%E4%BB%B6/5.%20IO%20%E7%AE%A1%E7%90%86_2025-08-01_17-41-28.png)

* 最先响应 IO 请求的是用户 IO 软件（库函数、系统调用接口，例如 C 语言中的 stdio 库，提供了 printf scanf 函数）
* 设备独立性软件：将不同的设备抽象成统一的文件系统接口，让程序员可以不需要关心底层的设备类型。同时管理设备的分配和释放，避免多个进程同时访问同一个设备。设备独立性软件的核心作用是提高系统的模块化和可移植性。
* 设备驱动程序：通常是设备制造商提供，是软件与硬件的桥梁。进行设备初始化、数据传输、错误恢复等任务。
* 中断处理程序：专门处理硬件中断的部分，由操作系统提供，设备厂商的设备驱动程序中调用的就是 OS 提供的中断处理程序的 API，设备完成操作或者发生异常的时候，硬件会触发中断信号，中断处理程序循序响应事件，保存中断现场，处理设备状态，通知上层软件。
* 最先响应硬件的是中断处理程序。
### DMA 方式
DMA 的工作流程
1. 初始化 DMA 控制器，并启动磁盘
2. 从磁盘传输一块数据到内存缓冲区
3. DMA 控制器发中断请求，让 CPU 来处理
4. 执行"DMA 结束"中断服务程序.



## Spooling 技术
aka 联机并发外设操作、假脱机技术。

本质上是将需要发送到慢速外设的数据先存起来（注意是到硬盘中而不是内存中），然后设置一个独立的守护程序，负责将数据从硬盘按照外设的速度慢慢发给他，从而解放 CPU 的时间，让 CPU 可以和外围设备并行工作，而不是需要等待打印完成。
#### 典型应用

在多用户环境中，多个用户可能同时提交打印请求。如果没有 SPOOLing 技术，打印机必须一个一个处理，用户只能等待。而使用 SPOOLing 后：
- 所有打印任务首先被写入磁盘上的打印队列；
- 打印守护进程会按顺序读取队列任务并发送到打印机；
- 用户提交任务后立刻可以继续其他操作，无需等待打印完成。