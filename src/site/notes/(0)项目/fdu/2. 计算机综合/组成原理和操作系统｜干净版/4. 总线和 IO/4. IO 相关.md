---
{"dg-publish":true,"dg-path":"2. 计算机综合/组成原理和操作系统｜干净版/4. 总线和 IO/4. IO 相关.md","permalink":"/2//4-io/4-io/"}
---

## IO接口
### 硬件层次结构
![4. IO 相关_2025-12-11_18-38-55.png](/img/user/attachments/4.%20IO%20%E7%9B%B8%E5%85%B3_2025-12-11_18-38-55.png)

### 软件层次结构

软件层次可以分为这几层

| 层次        | 解释                                             |
| --------- | ---------------------------------------------- |
| 用户层 IO 软件 | OS 提供，像用户提供标准接口，例如 `std::in` 或者是 `printf()` 函数 |
| 设备独立性软件   | OS 提供，用于抽象不同硬件的差异                              |
| 设备驱动和程序   | 一般是硬件制造商提供，运行于 CPU 的内核态.                       |
| 中断处理程序    | 专门处理中断的程序，在最底层.                                |
| 硬件        | 实际做操作的硬件.                                      |
### 硬件细节
IO 接口规格、
硬件中的有缓存，数据可以在硬件中缓存然后成批交付，例如网卡可以按字节交付数据.
以及硬件的编制方式，可以统一编制，可以独立编制.

## IO方式
### 程序查询方式
CPU 定时来看有没有好，如果好了就直接和 IO设备之间传输数据，如果没有好的话，就过一会再来问.
### 程序中断方式获取 IO 设备状态
CPU 获取 IO 设备状态的方式有两种，一种是程序查询方式，就是 CPU 不断的来问 IO 设备准备好没好，显然这种方式是比较慢的，另外一种方式就是在 IO 准备数据期间，CPU 正常处理其他指令，当 IO 数据准备好了之后，就发一个中断信号给 CPU，这时 CPU 会暂停当前正在执行的任务，处理中断，然后恢复执行被中断的任务。这种方式效率比较高。
为了实现这个过程，需要有：
* 系统中断向量（指向中断处理程序入口的指针）
* 中断向量表（将中断号映射到中断处理程序的地址）
* 中断服务程序（ISR）（一段特殊代码，用于响应特定的中断事件，保存被中断程序的上下文例如寄存器状态，处理中断事件例如读取硬件设备的数据，恢复中断程序的上下文例如恢复寄存器状态。）
* ![6. 总线和输入输出设备_2025-07-19_17-44-22.png](/img/user/attachments/6.%20%E6%80%BB%E7%BA%BF%E5%92%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87_2025-07-19_17-44-22.png)

详见 [[(0)项目/fdu/2. 计算机综合/组成原理和操作系统｜干净版/3. CPU 和指令系统/3. 中断机制\|3. 中断机制]]