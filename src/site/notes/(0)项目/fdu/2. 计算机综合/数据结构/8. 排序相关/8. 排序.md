---
{"dg-publish":true,"dg-path":"2. 计算机综合/数据结构/8. 排序相关/8. 排序.md","permalink":"/2//8/8/"}
---

## 内部排序
内部排序总结：
需要掌握的内部排序一共有 9 种，其中四个不稳定，五个稳定。
不稳定的算法：「==快速==  ==选择==个==堆==的==希==望」（四个不稳定的）

| 算法名称       | 时间复杂度    | 空间复杂度                          | 稳定性                  | 特点                                                                                                                                                                                                                                                                 |
| ---------- | -------- | ------------------------------ | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 桶排序        | n+k 理想情况 | o(n+k)                         | 稳定                   | 和归并排序很像，但是没有归并排序那么严格的要求。<br>桶排序 = 先把数据分桶，然后桶内排序，最后合并所有桶。<br>桶排序是做了一个预设，根据待排序元素的范围分桶，比如 1-100 一个，101-200 一个然后做桶内排序，因此其时间复杂度和数据的分布相关，不像是归并排序是稳定的的 nlogn. 好处是分布均匀的时候可以在线性关系内完成计算.<br><br>Mapreduce 就是基于桶排序做的，所以才会有数据倾斜的问题。一旦倾斜出现，会导致排序效率大打折扣，最差就是都分到一个桶内，变成 n^2 的复杂度. |
| 基数排序       | d*(n+k)  |                                | 稳定                   | 在通排序基础上衍生出来的，按照基数分桶，然后桶内用稳定的排序算法，LSD 就是先比较最低位，然后比较次低位，最后完成所有的比较.                                                                                                                                                                                                   |
| 归并排序       | nlogn    | o (n)                          | 稳定                   | 经典分治思想，两路归并就是将待排序序列分为两个，然后对分好的继续分，直到每个待排序序列都是两个，然后再合并所有的有序序列稳定，是一个很好的排序算法，                                                                                                                                                                                         |
| 堆排序        | nlogn    | O (1) ，堆排序使用数组存储元素，在原地通过下标操作数据 | 不稳定，堆只管上下的关系，不管左右的关系 | 特点是使用顺序存储的完全二叉树，在原地通过下标直接操作序列，技巧性很强的方法. 软硬件一体的代表.                                                                                                                                                                                                                  |
| 快速排序（平均情况） | nlogn    | log 2 n 有递归栈                   | 不稳定，左右移动元素           |                                                                                                                                                                                                                                                                    |
| 冒泡排序       | n^2      | 原地操作，O (1) 的复杂度                | 稳定                   | 经典两层 for 循环结构                                                                                                                                                                                                                                                      |
| 选择排序       | n^2      | 原地操作，O (1) 的复杂度                | 不稳定                  | 每次从待排序的部分挑最小的，挑到了就跟下一个待排序的元素交换位置，这种交换带来了不稳定的后果.<br>简单选择排序的问题是每次都要遍历无序的序列，因此比较次数是固定的（很多），但是好处是移动元素次数少，这跟直接插入排序正好相反.                                                                                                                                                 |
| 插入排序       | n^2      | 原地操作，O (1) 的复杂度                | 稳定                   | 待待排序的排好队，一个一个来，倒着往前找要插入的位置，因此是稳定的.<br><br>适合绝大多数有序的序列. 因为每次插入都会需要插入位置的元素都往后移动.<br><br>因此出现了改良版的希尔排序，减少移动次数。                                                                                                                                                        |
| 希尔排序（最坏情况） |          | 原地操作，O (1) 的复杂度                | 不稳定，跳着找要插入的元素        | 跨步长的插入排序，先从整体上改善有序性，然后逐步减少步长，直到为 1，为 1 的时候实际上就是普通的插入排序了                                                                                                                                                                                                            |
| 快速排序（最坏情况） |          | log 2 n 有递归栈                   | 不稳定，左右移动元素           |                                                                                                                                                                                                                                                                    |

### 堆排序
 时间复杂度: $n\log n$
 空间复杂度 $O(n)$
* 堆就是一个完全二叉树，树中的每个节点都和它的孩子比都是有序的，分为大顶堆和小顶堆，顾名思义，大顶堆就是每个节点都比它的孩子节点大（或相同）。即全部数据中最大的那个元素是整个完全二叉树的根节点.
* 获取最大元素/最小元素的时间复杂度 O (1)
#### 构造初始堆的过程
* 堆排序实际的物理存储使用的是二叉树的顺序存储，即使用数组来存储二叉树。详细可见[堆相关](onenote:https://d.docs.live.net/31BC0CA0E8257E9D/文档/FDU/我爱408/自由费曼｜真题补充.one#堆相关&section-id={8B3C7D46-872E-5E44-A45F-7EBF30FB7D17}&page-id={21FBFCB5-FC0B-A646-A923-0B5A87C88D9D}&end)  ([Web view](https://onedrive.live.com/view.aspx?resid=31BC0CA0E8257E9D%2111739&id=documents&wd=target%28%E6%88%91%E7%88%B1408%2F%E8%87%AA%E7%94%B1%E8%B4%B9%E6%9B%BC%EF%BD%9C%E7%9C%9F%E9%A2%98%E8%A1%A5%E5%85%85.one%7C8B3C7D46-872E-5E44-A45F-7EBF30FB7D17%2F%E5%A0%86%E7%9B%B8%E5%85%B3%7C21FBFCB5-FC0B-A646-A923-0B5A87C88D9D%2F%29&wdpartid=%7b41214AEE-3493-B103-397F-AF9DCBAA6115%7d%7b1%7d&wdsectionfileid=31BC0CA0E8257E9D!s978f9548b9ea4655936d7ca4676d57e8))
* 插入
	* 将新元素插入到堆底（数组的末尾）
	* 从新元素开始，向上与父节点比较，若大于父节点则交换（大顶堆，上浮）
	* 重复上浮直到满足堆要求
	* 这个过程中左右节点并没有大小关系，做的操作一直都是节点与子节点交换位置，然后循环做这个操作。
### 快速排序
分治的思想，每次选中一个中轴，然后将比中轴小的元素都移动到该元素左侧，比中轴大的都移动到右侧，这样一次结束后，中轴元素所在的位置就是其最终的位置。
时间复杂度：$O(n\log_{2}n), 最坏O(n^2)$
空间复杂度：$O(\log_{2}n)$

```c++
// 记忆：先判断结束，带等号；
// 从右往左找，找到后覆盖左边
// 从左往右找，找到后覆盖右边
// 都结束后放回 pivot

// 左右子序列同样操作。

void quickSort(int a[], int low, int high) {
    if (low >= high) return; //全部排序结束
    
    int pivot = a[low]; // 选择第一个元素为基准，用一个变量先存上，等会这个位置可能会被覆盖掉。
    int l = low, r = high;
    
    while (l < r) { // 从右往左找，从右往右找，直到两个碰上结束本轮排序, 不能是<=
        while (l < r && a[r] >= pivot) r--; // 从右向左找小于 pivot 的，找到就停止，条件中不能是 l<= r, 否则 r 越过了l
        a[l] = a[r]; // 覆盖左边
        while (l < r && a[l] <= pivot) l++; // 从左向右找大于 pivot 的
        a[r] = a[l]; // 覆盖右边
    }
    a[l] = pivot; // 放回 pivot 到最终位置
     
    quickSort(a, low, l - 1);  // 排序左边
    quickSort(a, l + 1, high); // 排序右边
}
```

| 趟数  | 排序后结果         | pivot |
| --- | ------------- | ----- |
| 初始  | `3 7 1 9 2 6` |       |
| 1   | `2 1 3 9 7 6` | 3     |
| 2   | `1 2 3 9 7 6` | 2     |
| 3   | `1 2 3 6 7 9` | 9     |
| 4   | `1 2 3 6 7 9` | 6     |

### 插入排序
思想：
* 将数组分为有序的和无序的两部分，每次在有序的序列里查找应该插入的位置。
* 每次将无序的第一个元素A插入到有序的部分里
* 将 A 插入的时候，是在有序的序列中从后往前找应该插入的位置
时间复杂度：$n^2$, 平均情况下，每个元素要与前面一半的元素进行比较。

适合绝大多数有序的场景，最坏情况是整个数组都是倒序的。


模拟： `4 3 2 10 12 1 5 6`

| 趟数  | 数组结果                | 本轮插入的元素 |
| --- | ------------------- | ------- |
| 初始  | `4 3 2 10 12 1 5 6` | -       |
| 1   | `3 4 2 10 12 1 5 6` | 3       |
| 2   | `2 3 4 10 12 1 5 6` | 2       |
| 3   | `2 3 4 10 12 1 5 6` | 10      |
| 4   | `2 3 4 10 12 1 5 6` | 12      |
| 5   | `1 2 3 4 10 12 5 6` | 1       |
| 6   | `1 2 3 4 5 10 12 6` | 5       |
| 7   | `1 2 3 4 5 6 10 12` | 6       |
### 选择排序

思想：
* 将数组分为两部分，有序部分和无序部分，每次在无序的部分里选择下一个放到有序部分的元素。
* 每一次都选择无序部分里面找到最小的那个元素，然后将该元素放在有序部分的下一个位置（与最小的那个元素交换位置）
时间复杂度：$O(n^2)$
模拟： `11 25 12 22 64`

| 趟数  | 数组结果             | 本轮选择的元素 |
| --- | ---------------- | ------- |
| 初始  | `11 25 12 22 64` | -       |
| 1   | `11 25 12 22 64` | 11      |
| 2   | `11 12 25 22 64` | 12      |
| 3   | `11 12 22 25 64` | 22      |
| 4   | `11 12 22 25 64` | 25      |
| 5   | `11 12 22 25 64` | 64      |

### 归并排序
分治思想，将大问题拆解成小问题，然后组合小问题的解就是大问题的解。

以两路归并为例子：
* 两路归并的作用是将两个有序表合并成一个有序表。具体过程如下：
* 将数组分为两个子数组，然后继续将子数组分成两个子数组，直到每个子数组中只有两个或者一个元素。
* 将每个子数组排成有序的
* 合并所有的子数组

时间复杂度：$n\log n$
空间复杂度: $O(n)$
稳定算法


### 希尔排序
插入排序的改良版本，在原始的插入排序中，每次都要在有序的序列中寻找应该在哪里插入下一个元素，一旦找到要插入的位置，该位置之后的元素都要移动，对于大量无序的数组来说成本非常高。

希尔排序就是先找个步长做一次插入排序，从整体上改善一下数据的无序性，然后再减少步长直到以 1 为步长进行一次插入排序。
时间复杂度: 可接近 $O(n\log n)$ , 最坏是 $O(n^2)$ ,不稳定.

### 桶排序
与归并排序很像，归并排序是将数据按照原始的位置划分成子数组，然后分别让子数组有序，最后合并所有的子数组，
桶排序则是按照值划分成不同的桶，然后桶内排序，最后合并所有的桶。
时间复杂度为 $O(n+k)$, 需要比较多的空间，空间复杂度为 $O(n+k)$




