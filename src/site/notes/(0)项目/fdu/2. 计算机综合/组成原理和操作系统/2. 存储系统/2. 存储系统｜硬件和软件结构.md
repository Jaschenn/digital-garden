---
{"dg-publish":true,"dg-path":"2. 计算机综合/组成原理和操作系统/2. 存储系统/2. 存储系统｜硬件和软件结构.md","permalink":"/2//2/2/"}
---

#### 主存的结构 
1. 内存一般都是用 DRAM，需要定时按行刷新，DRAM 的行地址和列地址是分时复用的，共用一组地址线，先传行地址再传列地址。
2. 主存拓展方式影响主存总容量和字长，分为三种：位拓展法，字拓展法、字位拓展法。
	1. 位拓展：即扩宽一个字的位数。一般配合低位交叉编址的方式，通过拓展字长来提高容量。
	2. 字拓展法：扩大总的字数. 配合高位交叉编址的方式.
3. 编址方式决定并行性和带宽，分为两种：
	1. 低位交叉编址：｜体内地址｜体号｜，每个存储器都有独立的 AR 和 DR，当读一个连续的数据的时候，其地址连续，则会被分散到不同的存储体中，因而可以提高带宽为原来的 N 倍. 
	2. 高位交叉编址: |体号｜体内地址｜，当要实现字拓展时来增加主存容量时，这种方式所有的存储体共用一套地址寄存器 AR 和数据寄存器 DR，因此无法提高带宽或访问效率。
对比 TLB 和 Cache，这两者一般用 SRAM，无需刷新、速度快。
> 对应的缺失处理可以通过硬件实现。

### 主存的中的数据存储结构

在主存中，数据并不是连续的存储在内存中的每一个比特位的，因为 CPU 只能按照次一次处理 32 位/64 位数据，本质上是离线的以 32 位/64 位为单位一哆嗦一哆嗦的处理数据（aka 按「字」处理，所谓字长就是 ALU 的宽度，也叫机器字长。）一个 Byte 又对应 8 bits，即主存通常按照字节编址，CPU 一次处理多个字节的数据，ALU 宽度是 32 位，就是 4 个字节，字长为 4。这是 ALU 的硬件固定死了的，每次不能多、不能少，只能按照这个宽度处理数据。对于的，每次往 ALU 送数据的时候，也是按照这个固定的宽度去送数据，因此，最好把主存按照一定的长度分成一段一段的，这样每次读的时候，就能正好读取完整的字节。实际的计算机中就是这么处理的，每个数据的起始地址都是 2^n 的倍数。这样要读的数据一次就能读取完成。

#anki 
 
对于结构体，既需要按照结构体整体对齐、又需要按照元素的长度对齐。直接看一个例子
```c
struct{
int a; // 4B 假设 存储的 12345678H
char b;// 1B 
short c; //2B， 假设存储的为 9ABCH
}
```
在内存中存储时，会进行两点优化：
1. 最终结构体大小是最大元素的倍数。原本的大小是 4+1+2=7 B，会被编译器优化填充位 8 B。
2. k 个字节大小的数据，其在内存中的地址必须是 K 的整倍数。

上面的结构会被编译器优化为：

| 字节1 | 字节2       | 字节 3 | 字节 4 |
| --- | --------- | ---- | ---- |
| a   | a         | a    | a    |
| b   | （padding） | c    | c    |


假设主存按照字节编制，从 4 号开始存储。按照小端存储，则最终存储为：

| 0 号 | 1 号 | 2 号 | 3 号 | 4 号  | 5 号  | 6 号  | 7 号  | 8 号 | 9 号       | 10 号 | 11 号 | 12 号 | 13 号 |
| --- | --- | --- | --- | ---- | ---- | ---- | ---- | --- | --------- | ---- | ---- | ---- | ---- |
|     |     |     |     | 78 H | 56 H | 34 H | 12 H | b   | （padding） | BCH  | 9A H |      |      |

## 外存
外存主要是研究机械磁盘，主要有两块内容。
### 机械磁盘的结构和编址方式
CHS 地址：｜柱面号｜盘片号｜扇区号｜
### 机械磁盘的数据读取周期
分为三部分：寻道时间+延迟时间+读取时间

外存的最小读取单元是扇区，不是字节，外存主要是一些机械机构构成，根本就无法做到按字节读取数据。