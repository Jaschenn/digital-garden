---
{"dg-publish":true,"dg-path":"2. 计算机综合/组成原理和操作系统｜干净版/3. CPU 和指令系统/3. CPU和指令系统｜硬件和软件结构.md","permalink":"/2//3-cpu/3-cpu/"}
---

## CPU 结构和运行流程

CPU 可以分为数据通路和控制器两部分。数据通路中又包含 ALU 等组合逻辑元件（两个输入一个输出）和寄存器等时序逻辑元件（先 ALU 再 PSW 再通用寄存器），其中也包括了用于异常时间检测和响应的电路。
### 数据通路
以 8086 CPU 为例子，寄存器们如下：

| 第一组：ABCD 通用寄存器  | 第二组：段寄存器，用于存储内存段的起始地址 | 变址寄存器，和数组指针有关 | 栈指针寄存器：用于函数调用时指明函数栈顶和底的地址 | 标记寄存器                                                                                         | 特殊寄存器            |
| --------------- | --------------------- | ------------- | ------------------------- | --------------------------------------------------------------------------------------------- | ---------------- |
| A: 累加           | CS：code segment 代码段   | SI：源变址寄存器     |                           | Flags  <br>其中包含 OF 和 CF  <br>  <br>OF：溢出为 1，结果和符号不同（有符号数补码表示）  <br>CF：将二进制数据当做无符号数运算，看是否借位/进位 | IR：指令寄存器，暂存读到的指令 |
| B：基址，存内存地址的     | DS：数据段                | DI：目标变址寄存器    |                           |                                                                                               | T：暂存 ALU 一端的输入   |
| C：计数寄存器，Counter | ES：附加数据段              |               |                           |                                                                                               |                  |
| D: Data         | SS：Stack Segment，堆栈段  |               |                           |                                                                                               |                  |

典型的 CPU 的运行流程为：取指、译码、执行、访存、写回五个阶段。由于每个阶段需要使用不同部分的硬件，所以可以编排成流水线。编排过程中有三种问题：
1. 数据冒险：数据还没加工出来，下一条指令要用这个数据，可以通过插气泡的方式，使流水线暂停一下解决。此外还可以通过旁路转发的技术直接将上一个结果送入下一条指令中，但是旁路转发无法解决 load-use 型的数据冒险。
2. 结构冒险：在流水线里的多条指令要在同一个时间访问同一个硬件，直接嗝屁，只能通过暂停流水线的方式解决。
3. 控制冒险：带有判断或者跳转的指令，运算结果还没出来的之后直接执行了下一条本不该执行的指令。要么停顿流水线，要么蒙一个结果，然后再反过来检查对不对，对了的话就继续，不对的话就重新执行。也能通过一些优化，让这种控制语句最后执行以减少影响。

### 寻址
寻址找到的地址一般被用于访存，但是该地址是在执行阶段由 ALU 算出来的，或者是通过 PC 自增可以计算出来的。

|                    |                  |                                                                                                                            |
| ------------------ | ---------------- | -------------------------------------------------------------------------------------------------------------------------- |
| 寻址方式               | 例子               | 说明                                                                                                                         |
| 立即数寻址              | MOV AX, 5        | 将 5 移动到寄存器 AX 中                                                                                                            |
| 寄存器寻址              | MOV AX，BX        | 将 BX 的数据移动到 AX 中                                                                                                           |
| 直接寻址               | MOV AX, [1000]   | 1000 是内存地址，直接读取内存中 1000 位置的数据，放入寄存器 AX 中                                                                                   |
| 间接寻址  <br>又称之寄存器寻址 | MOV AX, [R1]     | 先读 R1 中的数据，并把该数据当做内存地址，读取内存中该位置的数据，放入 AX 中。                                                                                |
| 基址寻址               | MOV AX，[BP-2]    | 先读基址寄存器 BP 中的值，然后读内存中 BP-2 位置的数据，放入寄存器 AX 中。                                                                               |
| 变址寻址               | MOV AX，[BX + SI] | 先读变址寄存器 BX 的值，然后加上偏移量 SI，将该处的数据放入寄存器 AX 中。                                                                                 |
| 相对寻址               | JMP [PC+offset]  | 先读取 PC 中的值，里面的值就是当前指令的虚拟地址，然后将该地址加一个偏移量，得到新地址，访问新地址的数据，一般用于跳转。  <br>⚠️，正常情况在顺序执行的时候，每次 PC 的值是根据上一条指令的地址+上一条指令的长度得到新指令的地址的。 |



## 指令系统的编码方式
指令的格式如下：

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="141px" width="461px" viewBox="-10 -10 481 161" content="&lt;mxGraphModel dx=&quot;937&quot; dy=&quot;1113&quot; grid=&quot;1&quot; gridSize=&quot;10&quot; guides=&quot;1&quot; tooltips=&quot;1&quot; connect=&quot;1&quot; arrows=&quot;1&quot; fold=&quot;1&quot; page=&quot;0&quot; pageScale=&quot;1&quot; pageWidth=&quot;850&quot; pageHeight=&quot;1100&quot; math=&quot;0&quot; shadow=&quot;0&quot;&gt;&lt;root&gt;&lt;mxCell id=&quot;0&quot;/&gt;&lt;mxCell id=&quot;1&quot; parent=&quot;0&quot;/&gt;&lt;mxCell id=&quot;2&quot; value=&quot;操作码&quot; style=&quot;rounded=0;whiteSpace=wrap;html=1;&quot; vertex=&quot;1&quot; parent=&quot;1&quot;&gt;&lt;mxGeometry x=&quot;30&quot; y=&quot;-40&quot; width=&quot;210&quot; height=&quot;60&quot; as=&quot;geometry&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=&quot;3&quot; value=&quot;地址&quot; style=&quot;rounded=0;whiteSpace=wrap;html=1;&quot; vertex=&quot;1&quot; parent=&quot;1&quot;&gt;&lt;mxGeometry x=&quot;270&quot; y=&quot;-40&quot; width=&quot;220&quot; height=&quot;60&quot; as=&quot;geometry&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=&quot;4&quot; value=&quot;INC&quot; style=&quot;rounded=0;whiteSpace=wrap;html=1;&quot; vertex=&quot;1&quot; parent=&quot;1&quot;&gt;&lt;mxGeometry x=&quot;30&quot; y=&quot;40&quot; width=&quot;210&quot; height=&quot;60&quot; as=&quot;geometry&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=&quot;5&quot; value=&quot;1234H&quot; style=&quot;rounded=0;whiteSpace=wrap;html=1;&quot; vertex=&quot;1&quot; parent=&quot;1&quot;&gt;&lt;mxGeometry x=&quot;270&quot; y=&quot;40&quot; width=&quot;220&quot; height=&quot;60&quot; as=&quot;geometry&quot;/&gt;&lt;/mxCell&gt;&lt;/root&gt;&lt;/mxGraphModel&gt;"><style type="text/css"></style><rect x="0.5" y="0.5" width="210" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="none"/><g><foreignObject pointer-events="none" width="100%" height="100%" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 208px; height: 1px; padding-top: 31px; margin-left: 2px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: none; white-space: normal; overflow-wrap: normal;">操作码</div></div></div></foreignObject></g><rect x="240.5" y="0.5" width="220" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="none"/><g><foreignObject pointer-events="none" width="100%" height="100%" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 218px; height: 1px; padding-top: 31px; margin-left: 242px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: none; white-space: normal; overflow-wrap: normal;">地址</div></div></div></foreignObject></g><rect x="0.5" y="80.5" width="210" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="none"/><g><foreignObject pointer-events="none" width="100%" height="100%" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 208px; height: 1px; padding-top: 111px; margin-left: 2px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: none; white-space: normal; overflow-wrap: normal;">INC</div></div></div></foreignObject></g><rect x="240.5" y="80.5" width="220" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="none"/><g><foreignObject pointer-events="none" width="100%" height="100%" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 218px; height: 1px; padding-top: 111px; margin-left: 242px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: none; white-space: normal; overflow-wrap: normal;">1234H</div></div></div></foreignObject></g></svg>

某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对 4 中寻址方式。则单地址指令中，直接寻址方式的可寻址范围是？

>  48 条指令，则操作码的位数至少为 6 位，才能给每个指令一个唯一的编码。
>  四种寻址方式，则需要 2 位来表示哪一种寻址方式。
>  指令的完整格式为：｜操作码｜寻址方式｜地址｜
>  故可用于表示地址的位数为 16-6-2=8 位，范围为[0, 255]




